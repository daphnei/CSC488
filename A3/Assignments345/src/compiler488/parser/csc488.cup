// Package and import specifications section.

package compiler488.parser;

import java_cup.runtime.*;		// Must always import this.

import compiler488.ast.ASTList;
import compiler488.ast.decl.ArrayDeclPart;
import compiler488.ast.decl.DeclarationPart;
import compiler488.ast.decl.MultiDeclarations;
import compiler488.ast.decl.RoutineDecl;
import compiler488.ast.decl.ScalarDecl;
import compiler488.ast.decl.ScalarDeclPart;
import compiler488.ast.expn.AnonFuncExpn;
import compiler488.ast.expn.ArithExpn;
import compiler488.ast.expn.BoolExpn;
import compiler488.ast.expn.CompareExpn;
import compiler488.ast.expn.EqualsExpn;
import compiler488.ast.expn.Expn;
import compiler488.ast.expn.FunctionCallExpn;
import compiler488.ast.expn.IdentExpn;
import compiler488.ast.expn.NotExpn;
import compiler488.ast.expn.SubsExpn;
import compiler488.ast.expn.UnaryMinusExpn;
import compiler488.ast.stmt.ExitStmt;
import compiler488.ast.stmt.GetStmt;
import compiler488.ast.stmt.LoopStmt;
import compiler488.ast.stmt.ProcedureCallStmt;
import compiler488.ast.stmt.PutStmt;
import compiler488.ast.stmt.ReturnStmt;
import compiler488.ast.stmt.WhileDoStmt;

/* User code components 1: action code components.
 * Code to be used inside the actions triggered when productions are matched.
 * If any common code is needed for more than one action , put it here.
 */
// action code {:
// your code goes HERE
//:};

/* User code components 2: parser code components. 
 * Modifications to the default generated parser
 */
parser code {:

	String lastError;
	
    /** Override the report_error method so it will display the line and
     * column of where the error occurred in the input as well as the
     * reason for the error which is passed into the method in the
     * String 'message'.
     * @param message  error message to print
     * @param info     symbol containing line/column numbers
     */
    public void report_error(String message, Object info)
	{
	String st =  "Error";
   
        if (info instanceof java_cup.runtime.Symbol)
	    {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

	    /* s.left is supposed to hold the line number of the error.
	     * s.right is supposed to hold the column number.
             * If either is < 0 the parser may have run off the end of the program
             * and a Syntax Error message without line number may be printed.
	     */
   
            if (s.left >= 0)				// Check line number.
		{
                st += " in line " + (s.left + 1);
                if (s.right >= 0)			// Check column number.
                    st += ", column " + (s.right + 1);
		}
            else
               st += " at end of input " ;
           }
	    st += ": " + message;
        System.err.println (st);
        lastError = st;
	}
   
    /** Override the report_fatal_error method to use the report_error method. */
    /** @throws SyntaxErrorException						*/
    public void report_fatal_error (String message, Object info) throws SyntaxErrorException
	{
        report_error (message, info);
        throw new SyntaxErrorException (lastError); 
	}
   
:};

/* User code components 3: initialization code.
 * If you want some code to be executed before the parser asks for the first
 * token, add it here.
 */
init with {:
:};

/* User code components 4: scanner specification code.
 * If you need to override the way the parser asks the scanner for the
 * next token, put your preferred method here.  Uncomment the line following
 * this comment, replace the line after that with your code, and uncomment
 * the line after that.
 */
// scan with {:
// your code goes here
// :};

/* Symbol lists section.
 * The names of terminals and non-terminals are not allowed to be CUP
 * reserved words.  These include "code", "action", "parser", "terminal",
 * "non", "nonterminal", "init", "scan", "with", "start", "precedence",
 * "left", "right", "nonassoc", "import", and "package".
 */

// DEFINITIONS for CSC488S Source Language  Winter  2009/2010 

// Terminals returned by the scanner with no value attached.  
terminal	AND,	OR,	NOT,	TRUE,	FALSE	;
terminal 	BOOLEAN,INTEGER,FUNCTION,PROCEDURE	;
terminal	BEGIN,	DO,	ELSE,	END,	EXIT	;
terminal	IF,	RETURN,	LOOP,	PUT,	GET	;
terminal	THEN,	WHILE,	SKIP,	YIELDS, WHEN	;

// Special-character terminals, no value attached
terminal	L_PAREN	,R_PAREN,L_SQUARE, R_SQUARE, L_CURLEY, R_CURLEY	;
terminal	EQUAL,	GREATER, LESS,	COMMA,  DOT	;
terminal	PLUS,	MINUS,	TIMES,  DIVIDE	;

// Terminals returned by the scanner with a value.
terminal String  IDENT	;
terminal Integer INTCONST	;
terminal String  TEXTCONST	;

// Non-terminals that have no value.
// nonterminal xxx

nonterminal	program,statement,	declaration,	scope	;
nonterminal	variablenames,		output			;
nonterminal	type,  	arguments,	parameters,	variable	;
nonterminal 	expression,	variablename 			;

nonterminal	declarationsAndStatements , inputs, outputs, bound , generalBound ;
nonterminal	procedureCall, parameter, conjunction, negation, compareExpn ;
nonterminal	arithExpn, term, factor, primary, constant ;

// Non-terminals that have a value.
// nonterminal type  nameList ;

// PLEASE NOTE: your grammar can not use the 'precedence'
// feature of java-cup. The lines below should remain
// commented.
//
//precedence left PLUS, MINUS;
//precedence left TIMES, DIVIDE;		// Higher precedence.

// The grammar section.

// This specifies the initial symbol of the grammar.
start with program;

/* Notice that sometimes the action must be inside the production rule,
 * not after it.  This is a subtle yet significant difference from YACC.
 * This is because the CUP parser is looking ahead one token.  It ALWAYS
 * reads one more token before it will act on the production.
 */

program		::=	scope:inside					// the main program
                        {: RESULT = Program(inside);           :}
            ; 

scope		::=	BEGIN declarationsAndStatements:inside END  	// non empty scope
                        {: RESULT = Scope(inside);           :} 
		|	BEGIN END				// empty scope
                        {: RESULT = Scope();           :}
		;

//  sequence of arbitrarily intermixed declarations and statements
declarationsAndStatements	::=	statement 
				|	declaration
				|	declarationsAndStatements statement
				|	declarationsAndStatements declaration
				;

statement	::=	variable:left LESS:mid EQUAL expression:right				// assignment statement
                        {: RESULT = new AssignStmt(left, right);          :} 
		|	IF:mid expression:ifExpr THEN declarationsAndStatements:thenBlock END 	// if statements
                        {: RESULT = new IfStmt(ifExpr, thenBlock);          :} 
		|	IF:mid expression:ifBlock THEN declarationsAndStatements:thenBlock ELSE declarationsAndStatements:elseBlock END
                        {: RESULT = new IfStmt(ifBlock, thenBlock, elseBlock);          :} 
		|	WHILE:mid expression:exp DO declarationsAndStatements:doBlock END	// while statement
                        {: RESULT = new WhileDoStmt(exp, doBlock);          :} 
		|	LOOP:mid declarationsAndStatements:loop END			// loop statement
                        {: RESULT = new LoopStmt(loop);          :} 
		|	EXIT:mid							// exit statements
                        {: RESULT = new ExitStmt();           :} 
		|	EXIT:mid WHEN expression:exp
                        {: RESULT = new ExitStmt();           :} 
		|	RETURN:mid 							// return statements
                        {: RESULT = new ReturnStmt();           :} 
		|	RETURN L_PAREN expression:exp R_PAREN
                        {: RESULT = new ReturnStmt(exp);           :} 
		|	PUT:mid outputs:out						// input/output statments
                        {: RESULT = new PutStmt(out);           :} 
		|	GET:mid inputs:in
                        {: RESULT = new GetStmt(in);           :} 
		|	procedureCall:proc						// procedure call
                        {: RESULT = new ProcedureCallStmt(proc);           :} 
		|	scope:in							// embedded scope
                        {: RESULT = in;    :}
		;

procedureCall	::=	IDENT 					// call procedure with no parameters
		|	IDENT L_PAREN arguments R_PAREN  	// call procedure with parameters
		;

declaration	::=	type:ty variablenames:var 			// declare scalar/array variables
                        {: RESULT = new MultiDeclarations(ty,var);           :}
		|	type:ty FUNCTION:mid IDENT:id scope:sc		// declare function
                        {: RESULT = new RoutineDecl(id,ty,sc);          :} 
		|	type:ty FUNCTION:mid IDENT:id L_PAREN parameters:para R_PAREN scope:sc
                        {: RESULT = new RoutineDecl(id,ty,para,sc);          :} 
		|	PROCEDURE:mid IDENT:id scope:sc			//  declare procedure
                        {: RESULT = new RoutineDecl(id,sc);          :} 
		|	PROCEDURE:mid IDENT:id L_PAREN parameters:para R_PAREN scope:sc
                        {: RESULT = new RoutineDecl(id,para,sc);          :} 
		;

variablenames	::=	variablename  				// list of variables being declared
		|	variablenames:many COMMA:mid variablename:more 
                        {: RESULT = many.add(more);           :} 
		;

variablename	::=	IDENT:var 						// scalar variable
                        {: ASTList<DeclarationPart> element = new ASTList<DeclarationPart>();
                            RESULT = element.add(new ScalarDeclPart(var));           :} 
		|	IDENT:var L_SQUARE bound:b R_SQUARE			// one dimensional array variable
                        {: ASTList<DeclarationPart> element = new ASTList<DeclarationPart>();
                            RESULT = element.add(new ArrayDeclPart(var,b[0],b[1]));           :} 
		|	IDENT:var L_SQUARE bound:b1 COMMA bound:b2  R_SQUARE	// two dimensional array variable
                        {: ASTList<DeclarationPart> element = new ASTList<DeclarationPart>();
                            RESULT = element.add(new ArrayDeclPart(var,b1[0],b1[1],b2[0],b2[1]));           :} 
		;

bound		::=	INTCONST:g					// positive array bound
                        {: RESULT = new int[] {g,0};           :}
		|	generalBound:g1 DOT DOT generalBound:g2		// positive or negative array bounds
                        {: RESULT = new int[] {g1,g2};           :}
		;
		
generalBound	::=	INTCONST:val		// positive array bound
                        {: RESULT = val; :}
		|	MINUS INTCONST:val		// negative array bound
                        {: RESULT = -val; :}
		;

type		::=	INTEGER			// integer type
		|	BOOLEAN			// boolean type
		;

outputs		::=	output			// list of output expressions
		|	outputs COMMA output
		;

output		::=	expression		// integer expression
		|	TEXTCONST:txt		// text constant
                        {: RESULT = many.add(ScalarDeclPart(more));           :}
		|	SKIP			// skip pseudo constant
		;

inputs		::=	variable		// list of variables being read into
		|	inputs COMMA variable
		;

arguments	::=	expression			// list of function/procedure arguments
		|	arguments COMMA:mid expression
		;

parameters	::=	parameter			// list of function/procedure formal parameters
		|	parameters:many COMMA:mid parameter:more
                        {: RESULT = many.add(new ScalarDeclPart(more));           :} 
		;

parameter	::=	type:ty IDENT:var 			// declare one parameter
                        {: ASTList<DeclarationPart> element = new ASTList<DeclarationPart>();
                            RESULT = element.add(new ScalarDecl(var,ty));           :} ;

expression	::=	conjunction			// disjunctions, associate left-to-right
		|	expression:exp1 OR:mid conjunction:exp2
                        {: RESULT = new BoolExpn("|",exp1,exp2);          :} 
		;

conjunction	::=	negation			// conjunctions, associate left-to-right
		|	conjunction:exp1 AND:mid negation:exp2
                        {: RESULT = new BoolExpn("&",exp1,exp2);          :} 
		;

negation	::=	compareExpn 			// negations
		|	NOT:mid negation:neg
                        {: RESULT = new NotExpn(neg);          :} 
		;

compareExpn	::=	arithExpn			// comparisons, do not associate
		|	arithExpn:(Expn) exp1 EQUAL:mid arithExpn:exp2
                        {: RESULT = new EqualsExpn("=",exp1,exp2);          :} 
		| 	arithExpn:exp1 NOT:mid EQUAL arithExpn:exp2
                        {: RESULT = new EqualsExpn("!=",exp1,exp2);          :} 
		|	arithExpn:exp1 LESS:mid arithExpn:exp2
                        {: RESULT = new CompareExpn("<",exp1,exp2);          :} 
		|	arithExpn:exp1 LESS:mid EQUAL arithExpn:exp2
                        {: RESULT = new CompareExpn("<=",exp1,exp2);          :} 
		|	arithExpn:exp1 GREATER:mid arithExpn:exp2
                        {: RESULT = new CompareExpn(">",exp1,exp2);          :} 
		|	arithExpn:exp1 GREATER:mid EQUAL arithExpn:exp2
                        {: RESULT = new CompareExpn(">=",exp1,exp2);          :} 
		;

arithExpn	::=	term				// expressions, associate + , - left-to-right
		|	arithExpn:left  PLUS:mid  term:right
                        {: RESULT = new ArithExpn("+");          :}
		|	arithExpn:left  MINUS:mid term:right
                        {: RESULT = new ArithExpn("-");          :}
		;

term		::=	factor				// terms, associate * , /   left-to-right
		|	term:left TIMES:mid factor:right
                        {: RESULT = new ArithExpn("*");          :}
		|	term:left DIVIDE:mid factor:right
                        {: RESULT = new ArithExpn("/");          :}
		;

factor		::=	primary				// unary minus
		|	MINUS:mid factor:fac
                        {: RESULT = new UnaryMinusExpn(fac);          :}
		;

primary		::=	constant				// integer or boolean constant
		|	variable				// scalar, array variable or function call
		|	IDENT:id L_PAREN:mid arguments:arg R_PAREN 	// function call
                        {: RESULT = new FunctionCallExpn(id,arg);          :} 
		| 	L_PAREN  expression  R_PAREN		// parenthesized expression
		|	L_CURLEY declarationsAndStatements:body YIELDS:mid expression:exp R_CURLEY	// anon function
                        {: RESULT = new AnonFuncExpn(body,exp);          :} 
		;

constant	::=	INTCONST:integer	// integer constant
                        {: RESULT = IntConstExpn(integer);           :} 
		|	TRUE:t		// constant true
                        {: RESULT = BoolConstExpn(t);           :} 
		|	FALSE:f		// constant false
                        {: RESULT = BoolConstExpn(f);           :} 
		;

variable	::=	IDENT:id					// scalar variable or function call
                        {: RESULT = new IdentExpn(id);           :} 
		|	IDENT:id L_SQUARE:mid expression:exp R_SQUARE	// element of a 1-D  array
                        {: RESULT = new SubsExpn(id,exp);          :} 
		|	IDENT:id L_SQUARE:mid expression:exp1 COMMA expression:exp2 R_SQUARE	// element of a 2-D array
                        {: RESULT = new SubsExpn(id, (Expn)exp1, (Expn)exp2);          :} 
		;

